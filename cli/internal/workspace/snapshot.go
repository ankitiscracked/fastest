package workspace

import (
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/anthropics/fastest/cli/internal/config"
	"github.com/anthropics/fastest/cli/internal/manifest"
	"github.com/anthropics/fastest/cli/internal/store"
)

// SnapshotResult contains the output of a Snapshot operation.
type SnapshotResult struct {
	SnapshotID   string
	ManifestHash string
	Files        int
	Size         int64
	BlobsCached  int
}

// SnapshotOpts configures a Snapshot operation.
type SnapshotOpts struct {
	Message   string
	Agent     string // agent name, if message was generated by an agent
	Author    *config.Author
	ParentIDs []string // explicit parent IDs; nil = auto-resolve from config + merge parents
}

// Snapshot captures the current workspace state as an immutable snapshot.
// It generates a manifest, caches blobs, writes snapshot metadata to the
// project store, updates the workspace config, and populates the stat cache.
func (ws *Workspace) Snapshot(opts SnapshotOpts) (*SnapshotResult, error) {
	// Resolve author
	author := opts.Author
	if author == nil {
		a, _ := config.LoadAuthor()
		if a == nil {
			a = &config.Author{}
		}
		author = a
	}

	// Generate manifest
	m, err := manifest.Generate(ws.root, false)
	if err != nil {
		return nil, fmt.Errorf("failed to scan files: %w", err)
	}

	// Populate stat cache
	manifest.BuildStatCacheFromManifest(ws.root, m, ws.StatCachePath())

	manifestHash, err := m.Hash()
	if err != nil {
		return nil, fmt.Errorf("failed to compute manifest hash: %w", err)
	}

	// Cache blobs
	blobsCached := 0
	if err := ws.store.EnsureDirs(); err != nil {
		return nil, fmt.Errorf("failed to ensure store directories: %w", err)
	}
	for _, f := range m.FileEntries() {
		if ws.store.BlobExists(f.Hash) {
			continue
		}
		content, err := os.ReadFile(filepath.Join(ws.root, f.Path))
		if err != nil {
			return nil, fmt.Errorf("failed to read file for blob cache %s: %w", f.Path, err)
		}
		if err := ws.store.WriteBlob(f.Hash, content); err != nil {
			return nil, fmt.Errorf("failed to cache blob for %s: %w", f.Path, err)
		}
		blobsCached++
	}

	// Write manifest
	if !ws.store.ManifestExists(manifestHash) {
		if _, err := ws.store.WriteManifest(m); err != nil {
			return nil, fmt.Errorf("failed to write manifest: %w", err)
		}
	}

	// Resolve parent IDs
	parents := opts.ParentIDs
	if parents == nil {
		parents = ws.resolveSnapshotParents()
	}

	// Compute content-addressed snapshot ID
	createdAt := time.Now().UTC().Format(time.RFC3339)
	snapshotID := store.ComputeSnapshotID(manifestHash, parents, author.Name, author.Email, createdAt)

	// Write snapshot metadata
	meta := &store.SnapshotMeta{
		ID:                snapshotID,
		WorkspaceID:       ws.cfg.WorkspaceID,
		WorkspaceName:     ws.cfg.WorkspaceName,
		ManifestHash:      manifestHash,
		ParentSnapshotIDs: parents,
		AuthorName:        author.Name,
		AuthorEmail:       author.Email,
		Message:           opts.Message,
		Agent:             opts.Agent,
		CreatedAt:         createdAt,
		Files:             m.FileCount(),
		Size:              m.TotalSize(),
	}

	if err := ws.store.WriteSnapshotMeta(meta); err != nil {
		return nil, fmt.Errorf("failed to write snapshot metadata: %w", err)
	}

	// Update workspace config â€” this is the commit point. If we crash
	// after writing the snapshot but before saving config, the snapshot
	// is orphaned but harmless (GC will clean it up). Once config is
	// saved, the workspace points to the new snapshot.
	ws.cfg.CurrentSnapshotID = snapshotID
	if err := ws.SaveConfig(); err != nil {
		return nil, fmt.Errorf("failed to update workspace config: %w", err)
	}

	// Clear pending merge parents (post-commit cleanup, non-fatal)
	_ = config.ClearPendingMergeParentsAt(ws.root)

	// Update project-level workspace registry (non-fatal)
	_ = ws.store.UpdateWorkspaceHead(ws.cfg.WorkspaceID, snapshotID)

	return &SnapshotResult{
		SnapshotID:   snapshotID,
		ManifestHash: manifestHash,
		Files:        m.FileCount(),
		Size:         m.TotalSize(),
		BlobsCached:  blobsCached,
	}, nil
}

// AutoSnapshot creates a snapshot silently if there are changes since the
// current snapshot. Returns the snapshot ID, or empty string if no changes.
// Used before destructive operations (merge, restore, pull).
func (ws *Workspace) AutoSnapshot(message string) (string, error) {
	// Generate manifest
	m, err := manifest.Generate(ws.root, false)
	if err != nil {
		return "", fmt.Errorf("failed to scan files: %w", err)
	}

	manifest.BuildStatCacheFromManifest(ws.root, m, ws.StatCachePath())

	manifestHash, err := m.Hash()
	if err != nil {
		return "", fmt.Errorf("failed to compute manifest hash: %w", err)
	}

	// Skip if no changes since current snapshot
	if ws.cfg.CurrentSnapshotID != "" {
		if currentHash, err := ws.store.ManifestHashFromSnapshotID(ws.cfg.CurrentSnapshotID); err == nil && currentHash == manifestHash {
			return "", nil
		}
	}

	// Use simple parent chain (current snapshot only, no merge parents)
	var parentIDs []string
	if ws.cfg.CurrentSnapshotID != "" {
		parentIDs = []string{ws.cfg.CurrentSnapshotID}
	}

	result, err := ws.Snapshot(SnapshotOpts{
		Message:   message,
		ParentIDs: parentIDs,
	})
	if err != nil {
		return "", err
	}
	return result.SnapshotID, nil
}

// resolveSnapshotParents determines parent snapshot IDs from pending merge
// parents or the current snapshot.
func (ws *Workspace) resolveSnapshotParents() []string {
	if parents, err := config.ReadPendingMergeParentsAt(ws.root); err == nil && len(parents) > 0 {
		return dedup(parents)
	}
	if ws.cfg.CurrentSnapshotID != "" {
		return []string{ws.cfg.CurrentSnapshotID}
	}
	return nil
}

func dedup(ss []string) []string {
	seen := make(map[string]struct{}, len(ss))
	out := make([]string, 0, len(ss))
	for _, s := range ss {
		if s == "" {
			continue
		}
		if _, ok := seen[s]; ok {
			continue
		}
		seen[s] = struct{}{}
		out = append(out, s)
	}
	return out
}
